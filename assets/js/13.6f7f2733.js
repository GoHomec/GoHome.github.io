(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{584:function(s,a,t){"use strict";t.r(a);var n=t(6),e=Object(n.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"java常见基础面试题总结-02"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java常见基础面试题总结-02"}},[s._v("#")]),s._v(" 🔍JAVA常见基础面试题总结 02")]),s._v(" "),t("h2",{attrs:{id:"一、面向对象基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、面向对象基础"}},[s._v("#")]),s._v(" 一、面向对象基础")]),s._v(" "),t("h3",{attrs:{id:"面向对象和面向过程的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象和面向过程的区别"}},[s._v("#")]),s._v(" 面向对象和面向过程的区别?")]),s._v(" "),t("p",[s._v("两者主要的区别在于解决问题的方式不同:")]),s._v(" "),t("ul",[t("li",[s._v("面向过程把解决问题的过程拆分成一个个方法，通过一个个方法的执行来解决问题。")]),s._v(" "),t("li",[s._v("面向对象会先抽象出对象，然后通过对象执行方法的方式来解决问题。\n另外，面向对象开发的程序一般更易维护、易复用、易扩展")])]),s._v(" "),t("h3",{attrs:{id:"对象的相等和引用相等的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的相等和引用相等的区别"}},[s._v("#")]),s._v(" 对象的相等和引用相等的区别")]),s._v(" "),t("ul",[t("li",[s._v("对象的相等一般比较的是内存中存放的内容是否相等。")]),s._v(" "),t("li",[s._v("引用相等一般比较的是他们指向的内存地址是否相等。")])]),s._v(" "),t("h3",{attrs:{id:"构造方法有哪些特点-是否可被-override-】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造方法有哪些特点-是否可被-override-】"}},[s._v("#")]),s._v(" 构造方法有哪些特点？是否可被 override?】")]),s._v(" "),t("p",[s._v("构造方法特点如下：")]),s._v(" "),t("ul",[t("li",[s._v("名字与类名相同。")]),s._v(" "),t("li",[s._v("没有返回值，但不能用 void 声明构造函数。")]),s._v(" "),t("li",[s._v("生成类的对象时自动执行，无需调用。")])]),s._v(" "),t("p",[s._v("构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。")]),s._v(" "),t("h3",{attrs:{id:"面向对象三大特征"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象三大特征"}},[s._v("#")]),s._v(" 面向对象三大特征")]),s._v(" "),t("h3",{attrs:{id:"接口和抽象类有什么共同点和区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口和抽象类有什么共同点和区别"}},[s._v("#")]),s._v(" 接口和抽象类有什么共同点和区别？")]),s._v(" "),t("p",[s._v("共同点 ：")]),s._v(" "),t("ul",[t("li",[s._v("都不能被实例化。")]),s._v(" "),t("li",[s._v("都可以包含抽象方法。")]),s._v(" "),t("li",[s._v("都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）")])]),s._v(" "),t("p",[s._v("不同点:")]),s._v(" "),t("ul",[t("li",[s._v("接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。")]),s._v(" "),t("li",[s._v("一个类只能继承一个类，但是可以实现多个接口。")]),s._v(" "),t("li",[s._v("接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。")])]),s._v(" "),t("h3",{attrs:{id:"深拷贝和浅拷贝区别了解吗-什么是引用拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝区别了解吗-什么是引用拷贝"}},[s._v("#")]),s._v(" 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？")]),s._v(" "),t("h2",{attrs:{id:"二、java常用类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、java常用类"}},[s._v("#")]),s._v(" 二、Java常用类")]),s._v(" "),t("h3",{attrs:{id:"object-类的常见方法有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#object-类的常见方法有哪些"}},[s._v("#")]),s._v(" Object 类的常见方法有哪些？")]),s._v(" "),t("p",[s._v("Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("native")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("getClass")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("native")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("boolean")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("equals")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),s._v(" obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * naitive 方法，用于创建并返回当前对象的一份拷贝。\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("protected")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("native")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("clone")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("CloneNotSupportedException")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("toString")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("native")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("notify")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("native")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("notifyAll")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("native")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("wait")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("long")]),s._v(" timeout"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("InterruptedException")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("wait")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("long")]),s._v(" timeout"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" nanos"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("InterruptedException")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("wait")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("InterruptedException")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * 实例被垃圾回收器回收的时候触发的操作\n */")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("protected")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("finalize")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Throwable")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br"),t("span",{staticClass:"line-number"},[s._v("28")]),t("br"),t("span",{staticClass:"line-number"},[s._v("29")]),t("br"),t("span",{staticClass:"line-number"},[s._v("30")]),t("br"),t("span",{staticClass:"line-number"},[s._v("31")]),t("br"),t("span",{staticClass:"line-number"},[s._v("32")]),t("br"),t("span",{staticClass:"line-number"},[s._v("33")]),t("br"),t("span",{staticClass:"line-number"},[s._v("34")]),t("br"),t("span",{staticClass:"line-number"},[s._v("35")]),t("br"),t("span",{staticClass:"line-number"},[s._v("36")]),t("br"),t("span",{staticClass:"line-number"},[s._v("37")]),t("br"),t("span",{staticClass:"line-number"},[s._v("38")]),t("br"),t("span",{staticClass:"line-number"},[s._v("39")]),t("br"),t("span",{staticClass:"line-number"},[s._v("40")]),t("br"),t("span",{staticClass:"line-number"},[s._v("41")]),t("br"),t("span",{staticClass:"line-number"},[s._v("42")]),t("br"),t("span",{staticClass:"line-number"},[s._v("43")]),t("br"),t("span",{staticClass:"line-number"},[s._v("44")]),t("br")])]),t("h3",{attrs:{id:"和-equals-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#和-equals-的区别"}},[s._v("#")]),s._v(" == 和 equals() 的区别")]),s._v(" "),t("p",[s._v("== 对于基本类型和引用类型的作用效果是不同的：")]),s._v(" "),t("ul",[t("li",[s._v("对于基本数据类型来说，== 比较的是值。")]),s._v(" "),t("li",[s._v("对于引用数据类型来说，== 比较的是对象的内存地址。")])]),s._v(" "),t("blockquote",[t("p",[s._v("因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。")])]),s._v(" "),t("p",[s._v("equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。")]),s._v(" "),t("p",[s._v("equals() 方法存在两种使用情况：")]),s._v(" "),t("ul",[t("li",[s._v("类没有重写 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。")]),s._v(" "),t("li",[s._v("类重写了 equals()方法 ：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。")])]),s._v(" "),t("h3",{attrs:{id:"hashcode-有什么用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashcode-有什么用"}},[s._v("#")]),s._v(" hashCode() 有什么用？")]),s._v(" "),t("h3",{attrs:{id:"为什么要有-hashcode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要有-hashcode"}},[s._v("#")]),s._v(" 为什么要有 hashCode？")]),s._v(" "),t("h3",{attrs:{id:"string、stringbuffer、stringbuilder-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string、stringbuffer、stringbuilder-的区别"}},[s._v("#")]),s._v(" String、StringBuffer、StringBuilder 的区别？")]),s._v(" "),t("h3",{attrs:{id:"string-为什么是不可变的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-为什么是不可变的"}},[s._v("#")]),s._v(" String 为什么是不可变的?")]),s._v(" "),t("h3",{attrs:{id:"字符串拼接用-还是-stringbuilder"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串拼接用-还是-stringbuilder"}},[s._v("#")]),s._v(" 字符串拼接用“+” 还是 StringBuilder?")]),s._v(" "),t("h3",{attrs:{id:"string-equals-和-object-equals-有何区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-equals-和-object-equals-有何区别"}},[s._v("#")]),s._v(" String#equals() 和 Object#equals() 有何区别？")]),s._v(" "),t("h3",{attrs:{id:"字符串常量池的作用了解吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池的作用了解吗"}},[s._v("#")]),s._v(" 字符串常量池的作用了解吗？")]),s._v(" "),t("h3",{attrs:{id:"string-s1-new-string-abc-这句话创建了几个字符串对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-s1-new-string-abc-这句话创建了几个字符串对象"}},[s._v("#")]),s._v(' String s1 = new String("abc");这句话创建了几个字符串对象？')]),s._v(" "),t("h3",{attrs:{id:"intern-方法有什么作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#intern-方法有什么作用"}},[s._v("#")]),s._v(" intern 方法有什么作用?")]),s._v(" "),t("h3",{attrs:{id:"string-类型的变量和常量做-运算时发生了什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-类型的变量和常量做-运算时发生了什么"}},[s._v("#")]),s._v(" String 类型的变量和常量做“+”运算时发生了什么？")])])}),[],!1,null,null,null);a.default=e.exports}}]);