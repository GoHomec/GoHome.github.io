(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{584:function(a,t,s){"use strict";s.r(t);var n=s(6),r=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"java常见基础面试题总结-01"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java常见基础面试题总结-01"}},[a._v("#")]),a._v(" 🔍JAVA常见基础面试题总结 01")]),a._v(" "),s("h2",{attrs:{id:"一、基础概念与常识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、基础概念与常识"}},[a._v("#")]),a._v(" 一、基础概念与常识")]),a._v(" "),s("h3",{attrs:{id:"java-语言有哪些特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-语言有哪些特点"}},[a._v("#")]),a._v(" Java 语言有哪些特点?")]),a._v(" "),s("ol",[s("li",[a._v("语法简单，不需要指针")]),a._v(" "),s("li",[a._v("面向对象，与人类的思维模式一致")]),a._v(" "),s("li",[a._v("跨平台，一次编译到处运行")]),a._v(" "),s("li",[a._v("支持多线程与网络编程")]),a._v(" "),s("li",[a._v("可靠、安全 (Java取消了指针，提供了垃圾回收机制和异常处理机制)")]),a._v(" "),s("li",[a._v("编译与解释并存")])]),a._v(" "),s("h3",{attrs:{id:"浅谈jdk、jre、jvm区别与联系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浅谈jdk、jre、jvm区别与联系"}},[a._v("#")]),a._v(" 浅谈JDK、JRE、JVM区别与联系")]),a._v(" "),s("p",[a._v("JDK就是Java开发工具包，包含了编写Java程序所必须的编译、运行等开发工具以及JRE。JRE即为Java运行环境，提供了运行Java程序所必须的软件环境，包含有Java虚拟机(JVM)和丰富的系统类库。系统类库是为Java提前封装好的功能类，只需要拿来直接使用即可。JVM就是Java虚拟机，提供了字节码文件(.class)的运行环境支持。")]),a._v(" "),s("h3",{attrs:{id:"为什么-java-被称作是-平台无关的编程语言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么-java-被称作是-平台无关的编程语言"}},[a._v("#")]),a._v(" 为什么 Java 被称作是“平台无关的编程语言”？")]),a._v(" "),s("p",[a._v("Java语言的跨平台并不是指Java语言本身跨平台，而是Java源程序编译后的字节码文件的跨平台。\nJava程序执行过程是Java源文件编译成.class字节码文件，再\n由 JVM 翻译成不同操作平台的机器码并执行，跨平台指的是在不同操作平台上安装不同的JVM，但是字节码文件都是一样的，这是因为 JVM 屏蔽所有有关操作平台的信息， 字节码文件翻译成机器码 这个过程由JVM自主自动完成 ，我们只需要写源代码，再交由 Javac 编译成字节码文件即可，JVM 负责将 Java 字节码文件翻译成不同操作平台所能识别的机器码。")]),a._v(" "),s("h3",{attrs:{id:"什么是字节码-采用字节码的好处是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是字节码-采用字节码的好处是什么"}},[a._v("#")]),a._v(" 什么是字节码?采用字节码的好处是什么?")]),a._v(" "),s("p",[a._v("在Java中，可以被JVM理解的代码被称为字节码(后缀为.class的文件)。\nJava通过字节码的方式一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植性的特点。")]),a._v(" "),s("h3",{attrs:{id:"为什么说-java-语言-编译与解释并存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么说-java-语言-编译与解释并存"}},[a._v("#")]),a._v(" 为什么说 Java 语言“编译与解释并存”？")]),a._v(" "),s("p",[a._v("编译型 ：编译型语言 会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。")]),a._v(" "),s("p",[a._v("解释型 ：解释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。")]),a._v(" "),s("p",[a._v("这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。")]),a._v(" "),s("h3",{attrs:{id:"java-和-c-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-和-c-的区别"}},[a._v("#")]),a._v(" Java 和 C++ 的区别?")]),a._v(" "),s("ol",[s("li",[a._v("Java 不提供指针来直接访问内存，程序内存更加安全")]),a._v(" "),s("li",[a._v("Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。")]),a._v(" "),s("li",[a._v("Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。")]),a._v(" "),s("li",[a._v("C++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。")])]),a._v(" "),s("h2",{attrs:{id:"二、基本语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、基本语法"}},[a._v("#")]),a._v(" 二、基本语法")]),a._v(" "),s("h3",{attrs:{id:"continue、break-和-return-的区别是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#continue、break-和-return-的区别是什么"}},[a._v("#")]),a._v(" continue、break 和 return 的区别是什么？")]),a._v(" "),s("ol",[s("li",[a._v("continue 跳出当前这一次循环，继续下一次循环")]),a._v(" "),s("li",[a._v("break 跳出整个循环题，继续执行循环体下面的语句")]),a._v(" "),s("li",[a._v("return 跳出所在方法，结束该方法运行。return有两种用法：\n"),s("ol",[s("li",[a._v("return; 直接使用 return 结束方法执行，用于没有返回值函数的方法")]),a._v(" "),s("li",[a._v("return value; ：return 一个特定值，用于有返回值函数的方法")])])])]),a._v(" "),s("h3",{attrs:{id:"成员变量与局部变量的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#成员变量与局部变量的区别"}},[a._v("#")]),a._v(" 成员变量与局部变量的区别？")]),a._v(" "),s("ol",[s("li",[a._v("语法形式 ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 "),s("strong",[a._v("public")]),a._v(" , "),s("strong",[a._v("private")]),a._v(" , "),s("strong",[a._v("static")]),a._v(" 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。")]),a._v(" "),s("li",[a._v("存储方式 ：从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。")]),a._v(" "),s("li",[a._v("生存时间 ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。")]),a._v(" "),s("li",[a._v("默认值 ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。")])]),a._v(" "),s("h3",{attrs:{id:"静态方法和实例方法有何不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态方法和实例方法有何不同"}},[a._v("#")]),a._v(" 静态方法和实例方法有何不同？")]),a._v(" "),s("ol",[s("li",[a._v("静态方法是属于类的，实例方法是属于实例对象的。")]),a._v(" "),s("li",[a._v("静态方法的调用可以直接使用 类名.方法名 的方式调用，也可以使用 对象名.方法名 调用，而实例方法只能使用后者调用。也就是说，调用静态方法无需创建对象。")]),a._v(" "),s("li",[a._v("静态方法中只能访问静态成员，不能访问实例成员，而实例方法不存在这个限制。")])]),a._v(" "),s("h3",{attrs:{id:"静态方法为什么不能调用非静态成员"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态方法为什么不能调用非静态成员"}},[a._v("#")]),a._v(" 静态方法为什么不能调用非静态成员?")]),a._v(" "),s("ol",[s("li",[a._v("静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。")]),a._v(" "),s("li",[a._v("在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。")])]),a._v(" "),s("h3",{attrs:{id:"重载和重写有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重载和重写有什么区别"}},[a._v("#")]),a._v(" 重载和重写有什么区别？")]),a._v(" "),s("ol",[s("li",[a._v("重载就是同一个方法能根据输入的数据的不同，做出不同的处理。重写是子类继承父类的相同方法，输入一样的数据，但要做出跟父类不一样的响应时，你就要覆盖父类的方法。")]),a._v(" "),s("li",[a._v("重载是发生在同一个类中，方法名相同，参数类型、顺序、个数 其中之一不相同，方法的返回值和访问修饰符可以不同。")]),a._v(" "),s("li",[a._v("重写方法名、参数列表必须相同，子类方法返回值类型应当比父类方法返回值类型更小或相等。抛出的异常返回应该小于等于父类，访问修饰符应该大于等于父类。")])]),a._v(" "),s("h3",{attrs:{id:"什么是可变长参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是可变长参数"}},[a._v("#")]),a._v(" 什么是可变长参数？")]),a._v(" "),s("p",[a._v("可变长参数就是允许在调用方法时可以传入不定个数的参数，编译后实际会被转换成一个数组。可变长参数只能作为函数的最后一个形参参数。")]),a._v(" "),s("h4",{attrs:{id:"遇到方法重载的情况怎么办呢-会优先匹配固定参数还是可变参数的方法呢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遇到方法重载的情况怎么办呢-会优先匹配固定参数还是可变参数的方法呢"}},[a._v("#")]),a._v(" 遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？")]),a._v(" "),s("p",[a._v("会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。")]),a._v(" "),s("h2",{attrs:{id:"三、基本数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、基本数据类型"}},[a._v("#")]),a._v(" 三、基本数据类型")]),a._v(" "),s("h3",{attrs:{id:"java-中的几种基本数据类型了解么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-中的几种基本数据类型了解么"}},[a._v("#")]),a._v(" Java 中的几种基本数据类型了解么？")]),a._v(" "),s("p",[a._v("Java中有八种基本数据类型。"),s("br"),a._v("\n整型： byte(1个字节)、short(2个字节)、int(4个字节)、long(8个字节)。"),s("br"),a._v("\n浮点型：float(4个字节)、double(8个字节)"),s("br"),a._v("\n字符型：char(2个字节) "),s("br"),a._v("\n布尔型：boolean(1个字节)")]),a._v(" "),s("h3",{attrs:{id:"基本类型和包装类型的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本类型和包装类型的区别"}},[a._v("#")]),a._v(" 基本类型和包装类型的区别？")]),a._v(" "),s("ol",[s("li",[a._v("成员变量包装类型不赋值就是null，而基本类型不赋值有默认值，不是null。")]),a._v(" "),s("li",[a._v("包装类型可以用于泛型，基本类型不可以。")]),a._v(" "),s("li",[a._v("基本数据类型的局部变量存放在栈中，基本数据类型的成员变量(未被static修饰)存放在堆中。而包装类型属于对象类型，几乎都是存放在堆中。")])]),a._v(" "),s("h3",{attrs:{id:"包装类型的缓存机制了解么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#包装类型的缓存机制了解么"}},[a._v("#")]),a._v(" 包装类型的缓存机制了解么？")]),a._v(" "),s("h3",{attrs:{id:"自动装箱与拆箱了解吗-原理是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自动装箱与拆箱了解吗-原理是什么"}},[a._v("#")]),a._v(" 自动装箱与拆箱了解吗？原理是什么？")]),a._v(" "),s("p",[a._v("装箱就是用基本数据类型对应引用类型包起来。拆箱就是将包装类型转换为基本数据类型。")]),a._v(" "),s("p",[a._v("装箱其实就是调用了 包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法")]),a._v(" "),s("ul",[s("li",[a._v("Integer i = 10 等价于 Integer i = Integer.valueOf(10)")]),a._v(" "),s("li",[a._v("int n = i 等价于 int n = i.intValue();")])]),a._v(" "),s("h3",{attrs:{id:"为什么浮点数运算的时候会有精度丢失的风险"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么浮点数运算的时候会有精度丢失的风险"}},[a._v("#")]),a._v(" 为什么浮点数运算的时候会有精度丢失的风险？")]),a._v(" "),s("p",[a._v("数据在内存(计算机)中是以二进制的形式存在的，十进制转为二进制可能会出现取不尽的情况，这时候得到的结果会是一个接近准确的结果，却不一定是我们想要的结果。")]),a._v(" "),s("h3",{attrs:{id:"如何解决浮点数运算的精度丢失问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何解决浮点数运算的精度丢失问题"}},[a._v("#")]),a._v(" 如何解决浮点数运算的精度丢失问题？")]),a._v(" "),s("p",[a._v("BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。")]),a._v(" "),s("p",[a._v("通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BigDecimal")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BigDecimal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"1.0"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BigDecimal")]),a._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BigDecimal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"0.9"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BigDecimal")]),a._v(" c "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BigDecimal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"0.8"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BigDecimal")]),a._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("subtract")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BigDecimal")]),a._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("subtract")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 0.1 */")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 0.1 */")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Objects")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("equals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* true */")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br")])]),s("h3",{attrs:{id:"超过-long-整型的数据应该如何表示"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#超过-long-整型的数据应该如何表示"}},[a._v("#")]),a._v(" 超过 long 整型的数据应该如何表示？")]),a._v(" "),s("p",[s("strong",[a._v("BigInteger")]),a._v(" 内部使用 int[] 数组来存储任意大小的整形数据。\n相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。")])])}),[],!1,null,null,null);t.default=r.exports}}]);