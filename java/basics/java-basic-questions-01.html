#Java 基础面试总结

## Java 的特点

- **Java 是一门面向对象的编程语言**。
- **Java 具有平台独立性和移植性**。
  - Java 有一句口号：`Write once, run anywhere`，一次编写、到处运行。这也是 Java 的魅力所在。而实现这种特性的正是 Java 虚拟机 JVM。已编译的 Java 程序可以在任何带有 JVM 的平台上运行。你可以在 windows 平台编写代码，然后拿到 linux 上运行。只要你在编写完代码后，将代码编译成 .class 文件，再把 class 文件打成 jar 包，这个 jar 包就可以在不同的平台上运行了。


- **Java 具有稳健性**。

  - Java 是一个强类型语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java 要求显式的方法声明，它不支持 C 风格的隐式声明。这些严格的要求保证编译程序能捕捉调用错误，这就导致更可靠的程序。

  - 异常处理是 Java 中使得程序更稳健的另一个特征。异常是某种类似于错误的异常条件出现的信号。使用 `try/catch/finally`语句，程序员可以找到出错的处理代码，这就简化了出错处理和恢复的任务。 


## Java 是如何实现跨平台的？

​	Java 是通过 JVM（Java 虚拟机）实现跨平台的。

​	JVM 可以理解成一个软件，不同的平台有不同的版本。我们编写的 Java 代码，编译后会生成 .class 文件（字节码文件）。Java 虚拟机就是负责将字节码文件翻译成特定平台下的机器码，通过 JVM 翻译成机器码之后才能运行。不同平台下编译生成的字节码是一样的，但是由 JVM 翻译成的机器码却不一样。

​	只要在不同平台上安装对应的 JVM ，就可以运行字节码文件，运行我们编写的 Java 程序。

​	因此，运行 Java 程序必须有 JVM 的支持，因为编译的结果不是机器码，必须要经过 JVM 的翻译才能执行。

## Java 与 C++ 的区别

​	Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 兼容 C ，不但支持面向对象也支持面向过程。

​	Java 通过虚拟机从而实现跨平台特性， C++ 依赖于特定的平台。

​	Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。

​	Java 支持自动垃圾回收，而 C++ 需要手动回收。

​	Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。

## JDK/JRE/JVM三者的关系

**JVM**

​	英文名称（Java Virtual Machine），就是我们耳熟能详的 Java 虚拟机。Java 能够跨平台运行的核心在于 JVM 。

​	所有的 java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行。也就是说 class 文件并不直接与机器的操作系统交互，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。

​	针对不同的系统有不同的 jvm 实现，有 Linux 版本的 jvm 实现，也有 Windows 版本的 jvm 实现，但是同一段代码在编译后的字节码是一样的。这就是 Java 能够跨平台，实现一次编写，多处运行的原因所在。

**JRE**

​	英文名称（Java Runtime Environment），就是 Java 运行时环境。我们编写的 Java 程序必须要在 JRE 才能运行。它主要包含两个部分，JVM 和 Java 核心类库。

​	JRE 是 Java 的运行环境，并不是一个开发环境，所以没有包含任何开发工具，如编译器和调试器等。

​	如果你只是想运行 Java 程序，而不是开发 Java 程序的话，那么你只需要安装 JRE 即可。

**JDK**

​	英文名称（Java Development Kit），就是 Java 开发工具包

​	JDK 目录下有个 JRE ，也就是 JDK 中已经集成了 JRE，不用单独安装 JRE。

​	另外，JDK 中还有一些好用的工具，如 jinfo，jps，jstack 等。

**最后，总结一下 JDK/JRE/JVM，他们三者的关系**

​	**JRE = JVM + Java 核心类库**

​	**JDK = JRE + Java工具 + 编译器 + 调试器**

## Java 程序是编译执行还是解释执行？

​	先看看什么是编译型语言和解释型语言。

**编译型语言**

​	定义：在程序运行之前，通过编译器将源程序编译成机器码可运行的二进制，以后执行这个程序时，就不用再进行编译了。

​	优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高，可以脱离语言环境独立运行。

​	缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。

**总结**：执行速度快、效率高；依靠编译器、跨平台性差些。

**代表语言**：C、C++、Pascal、Object-C 以及 Swift。

**解释型语言**

​	定义：解释型语言的源代码不是直接翻译成机器码，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。在运行的时候才将源程序翻译成机器码，翻译一句，然后执行一句，直至结束。

优点：

1. 有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（如虚拟机）。
2. 灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。

缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。

总结：解释型语言执行速度慢、效率低；依靠解释器、跨平台性好。

代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby。



​	对于 Java 这种语言，它的**源代码**会先通过 javac 编译成**字节码**，再通过 jvm 将字节码转换成**机器码**执行，即 解释运行 和 编译运行 配合使用，所以可以称为混合型或者半编译型。

​	所以，对于 "Java 是解释执行" 这句话，这个说法不太准确。我们开发的 Java 的源代码，首先通过 Javac 编译成为字节码（bytecode），然后，在运行时，通过 Java 虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的 JVM，比如我们大多数情况使用的 Oracle JDK 提供的 Hotspot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于**编译执行**，而不是解释执行了。这也是 Java 作为一门面向对象语言，但运行速度却不慢的原因。

##什么是字节码？采用字节码的最大好处是什么

**字节码**：Java 源代码经过虚拟机编译器编译后产生的文件（即扩展为 .class 的文件），它不面向任何特定的处理器或操作系统，只面向虚拟机。

**采用字节码的好处**：

​	Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不面向任何特定的处理器或操作系统，因此，Java程序无须重新编译便可在多种不同的计算机上运行。

**先看下 java 中的编译器和解释器**：

​	Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行

```
Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。
```

## 面向对象和面向过程的区别？

面向对象和面向过程是一种软件开发思想。

- 面向过程就是分析出解决问题所需要的步骤，然后用函数按这些步骤实现，使用的时候依次调用就可以了。
- 面向对象是把构成问题事务分解成各个对象，分别设计这些对象，然后将他们组装成有完整功能的系统。面向过程只用函数实现，面向对象是用类实现各个功能模块。

## 面向对象有哪些特性？

面向对象四大特性：封装，继承，多态，抽象

​	1、封装就是将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类的方法实现对隐藏信息的操作和访问。 良好的封装能够减少耦合。

​	2、继承是从已有的类中派生出新的类，新的类继承父类的属性和行为，并能扩展新的能力，大大增加程序的重用性和易维护性。在  Java 中是单继承的，也就是说一个子类只有一个父类。接口可以多继承！

​	3、多态是同一个行为具有多个不同表现形式的能力。在不修改程序代码的情况下改变程序运行时绑定的代码。实现多态的三要素：继承、重写、父类引用指向子类对象。

​			**静态多态性：通过重载实现，相同的方法有不同的參数列表，可以根据参数的不同，做出不同的处理。**

​			**动态多态性：在子类中重写父类的方法。运行期间判断所引用对象的实际类型，根据其实际类型调用相应的方法。**

​	4、抽象。把客观事物用代码抽象出来。

## 面向对象编程的六大原则?

​	**对象单一职责**：我们设计创建的对象，必须职责明确，比如商品类，里面相关的属性和方法都必须跟商品相关，不能出现订单等不相关的内容。这里的类可以是模块、类库、程序集，而不单单指类。

​	**里式替换原则**：子类能够完全替代父类，反之则不行。通常用于实现接口时运用。因为子类能够完全替代基（父）类，那么这样父类就拥有很多子类，在后续的程序扩展中就很容易进行扩展，程序完全不需要进行修改即可进行扩展。比如IA的实现为A，因为项目需求变更，现在需要新的实现，直接在容器注入处更换接口即可.

​	**迪米特法则**，也叫最小原则，或者说最小耦合。通常在设计程序或开发程序的时候，尽量要高内聚，低耦合。当两个类进行交互的时候，会产生依赖。而迪米特法则就是建议这种依赖越少越好。就像构造函数注入父类对象时一样，当需要依赖某个对象时，并不在意其内部是怎么实现的，而是在容器中注入相应的实现，既符合里式替换原则，又起到了解耦的作用。

开闭原则：开放扩展，封闭修改。当项目需求发生变更时，要尽可能的不去对原有的代码进行修改，而在原有的基础上进行扩展。

​	**依赖倒置原则**：高层模块不应该直接依赖于底层模块的具体实现，而应该依赖于底层的抽象。接口和抽象类不应该依赖于实现类，而实现类依赖接口或抽象类。

​	**接口隔离原则**：一个对象和另外一个对象交互的过程中，依赖的内容最小。也就是说在接口设计的时候，在遵循对象单一职责的情况下，尽量减少接口的内容。

**简洁版**： 

- 单一职责：对象设计要求独立，不能设计万能对象。
- 开闭原则：对象修改最小化。
- 里式替换：程序扩展中抽象被具体可以替换（接口、父类、可以被实现类对象、子类替换对象）
- 迪米特：高内聚，低耦合。尽量不要依赖细节。
- 依赖倒置：面向抽象编程。也就是参数传递，或者返回值，可以使用父类类型或者接口类型。从广义上讲：基于接口编程，提前设计好接口框架。
- 接口隔离：接口设计大小要适中。过大导致污染，过小，导致调用麻烦。

## Java的基本数据类型有哪些？

- byte，8bit

- char，16bit

- short，16bit

- int，32bit

- float，32bit

- long，64bit

- double，64bit

- boolean，只有两个值：true、false，可以使⽤用 1 bit 来存储

  一个字节占八位！！！

|  简单类型  | boolean | byte |   char    | short |   Int   | long | float | double |
| :--------: | :-----: | :--: | :-------: | :---: | :-----: | :--: | :---: | :----: |
| 二进制位数 |    1    |  8   |    16     |  16   |   32    |  64  |  32   |   64   |
|   包装类   | Boolean | Byte | Character | Short | Integer | Long | Float | Double |

​	在 Java 规范中，没有明确指出 boolean 的大小。Java 语言表达式所操作的 boolean 值，在编译之后都使用 Java 虚拟机中的 int 数据类型来代替，而 boolean 数组将会被编码成 Java 虚拟机的 byte 数组，每个元素 boolean 元素占8位。这样我们可以得出 boolean 类型占了单独使用是 4 个字节，在数组中又是 1 个字 节。

​	使用 int 的原因是，对于当下 32 位的处理器（CPU）来说，一次处理数据是 32 位（这里不是指的 是 32/64 位系统，而是指CPU硬件层面），具有高效存取的特点。

## 为什么不能用浮点型表示金额？

​	由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。

​	建议使用 BigDecimal 或者 Long 来表示金额。

## 什么是值传递和引用传递？

​	值传递与引用传递实际上是求值策略中严格求值的一种概念。是确定编程语言中表达式的求值的一组规则。

​	值传递是对基本型变量而言的，传递的是该变量的一个拷贝副本，改变副本不影响原变量。

​	引用传递一般是对于对象型变量而言的，传递的是该对象的直接引用。

​	传对象共享传递是值传递的一种特例。会将该对象地址的副本进行传递，因为参数的地址都指向同同一个对象，改变副本会影响原变量。

**java 中不存在引用传递，只有值传递**。

​	官方文档明确指出了，对 Java 中的对象传递，采用的是传对象共享传递方式，会将对象的引用当作值传递出去。

## Java 的四种引用，强弱软虚 

- 强引用

  发生 gc 的时候不会被回收。我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。比如下面这段代码中的 object 和 str 都是强引用：

```java
Object object = new Object();
String str = "StrongReference";
```

​		如果一个对象具有强引用，那就类似于**必不可少的**物品，不会被垃圾回收器回收。当内存空间不足，Java 虚拟机宁愿抛出OutOfMemoryError 错误，使程序异常终止，也不回收这种对象。

​		如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。

- 软引用：

  软引用在程序内存不足时，会被回收。

  ```java
  // 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，
  // 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T
  SoftReference<String> wrf = new SoftReference<String>(new String("str"));
  ```

  可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM 就会回收早先创建 的对象。

- 弱引用

  弱引用就是只要 JVM 垃圾回收器发现了它，就会将之回收，使用方式：

```java
WeakReference wrf = new WeakReference(str);
```

​		在使用软引用和弱引用的时候，我们可以显示地通过System.gc()来通知JVM进行垃圾回收，但是要注意的是，虽然发出了通知，JVM不一定会立刻执行，也就是说这句是无法确保此时JVM一定会进行垃圾回收的。

- 虚引用 

​		虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。

​		注意 哦，其它引用是被JVM回收后才被传入 ReferenceQueue 中的。由于这个机制，所以虚引用大多 被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ， 使用例子：

```java
PhantomReference<String> prf = new PhantomReference<String>(new String("str"),
new ReferenceQueue<>());
```

​		可用场景： 对象销毁前的一些操作，比如说资源释放等。 Object.finalize() 虽然也可以做这 类动作，但是这个方式即不安全又低效 上诉所说的几类引用，都是指对象本身的引用，而不是指Reference的四个子类的引用 (SoftReference等)。

## 了解 Java 的包装类型吗？为什么需要包装类？

​	Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将 int 、double 等类型放进去的。因为集合的容器要求元素是 Object 类型。

​	为了让基本类型也具有对象的特征，就出现了包装类型。相当于将基本类型包装起来，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。

## 自动装箱和拆箱

Java中基础数据类型与它们对应的包装类见下表：

| 原始类型 | 包装类型  |
| :------- | :-------- |
| boolean  | Boolean   |
| byte     | Byte      |
| char     | Character |
| float    | Float     |
| int      | Integer   |
| long     | Long      |
| short    | Short     |
| double   | Double    |

​	装箱就是自动将基本数据类型转换为包装器类型（int-->Integer），调用方法：Integer 的 valueOf(int) 方法 

​	拆箱就是自动将包装器类型转换为基本数据类型（Integer-->int），调用方法：Integer 的 intValue方法

当基础类型与它们的包装类有如下几种情况时，编译器会**自动**帮我们进行装箱或拆箱：

- 赋值操作（装箱或拆箱）
- 进行加减乘除混合运算 （拆箱）
- 进行>,<,==比较运算（拆箱）
- 调用equals进行比较（装箱）
- ArrayList、HashMap 等集合类添加基础类型数据时（装箱）

示例代码：

```java
Integer x = 1; // 装箱 调⽤ Integer.valueOf(1)
int y = x; // 拆箱 调⽤了 X.intValue()
```

下面看一道常见的面试题：

```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b);

Integer c = 200;
Integer d = 200;
System.out.println(c == d);
```

输出：

```java
true
false
```

​	为什么第三个输出是 false ？看看 Integer 类的源码就知道啦。

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

​	`Integer c = 200;` 会调用 调⽤ `Integer.valueOf(200)`。而从 Integer 的 valueOf() 源码可以看到，这里的实现并不是简单的 new Integer ，而是用 IntegerCache 做一个 cache。

```java
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =
            sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
        if (integerCacheHighPropValue != null) {
            try {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            } catch( NumberFormatException nfe) {
                // If the property cannot be parsed into an int, ignore it.
            }
        }
        high = h;
    }
    ...
}
```

​	这是 IntegerCache 静态代码块中的一段，默认Integer cache 的下限是 -128，上限默认127。当赋值 100 给 Integer 时，刚好在这个范围内，所以从 cache 中取对应的 Integer 并返回，所以 a 和 b 返回的是同一个对象，所以 `==` 比较是相等的，当赋值 200 给 Integer 时，不在 cache 的范围内，所以会 new Integer 并返回，当然 `==` 比较的结果是不相等的。

## 缓存池

new Integer(123) 与 Integer.valueOf(123) 的区别在于：

- new Integer(123) 每次都会新建一个对象；
- Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。

```java
Integer x = new Integer(123); 
Integer y = new Integer(123); 
System.out.println(x == y); // false 

Integer z = Integer.valueOf(123); 
Integer k = Integer.valueOf(123); 
System.out.println(z == k); // true
```

​	valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)]; 
    return new Integer(i); 
}
```

​	在 Java 8 中，Integer 缓存池的大小默认为 -128~127。

##instanceof 关键字的作用

​	instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法 为：

```java
boolean result = obj instanceof Class
```

 	其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接 或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。

​	 注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能 确定类型，则通过编译，具体看运行时定。 

```java
boolean result = obj instanceof Class int i = 0; 
System.out.println(i instanceof Integer);//编译不通过 i必须是引用类型，不能是基本类型 
System.out.println(i instanceof Object);//编译不通过
```

```Java
Integer integer = new Integer(1); 
System.out.println(integer instanceof Integer);//true
```

```java
//false ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返 回 false。
 System.out.println(null instanceof Object)
```

```java
static final int low = -128;
static final int high; 
static final Integer cache[];
static {
    // high value may be configured by property
    int h = 127;
    String integerCacheHighPropValue =
		sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
	if (integerCacheHighPropValue != null) {
		try {
			int i = parseInt(integerCacheHighPropValue);
			i = Math.max(i, 127);
			// Maximum array size is Integer.MAX_VALUE
			h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
		} catch( NumberFormatException nfe) {
			// If the property cannot be parsed into an int, ignore it.
		}
	}
	high = h;
	cache = new Integer[(high - low) + 1];
	int j = low;
	for(int k = 0; k < cache.length; k++)
		cache[k] = new Integer(j++);
		// range [-128, 127] must be interned (JLS7 5.1.7)
	assert IntegerCache.high >= 127;
}

```

​	编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用 自动装箱来创建，那么就会引用相同的对象。

基本类型对应的缓冲池如下： 

- sboolean values true and false 
- all byte values 
- short values between -128 and 127 
- int values between -128 and 127 
- char in the range \u0000 to \u007F

​	在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的 对象。

​	 在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax= 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定 上界。

## String 为什么不可变？

​	先看看什么是不可变的对象。

​	如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。

​	接着来看Java8 String类的源码：

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];

    /** Cache the hash code for the string */
    private int hash; // Default to 0
}
```

​	从源码可以看出，String 对象其实在内部就是一个个字符，存储在这个char类型的 value 数组里面的。

​	value 数组用 final 修饰，final 修饰的变量，值不能被修改。因此 value 不可以指向其他对象。

​	String 类内部所有的字段都是私有的，也就是被 private 修饰。而且 String 没有对外提供修改内部状态的方法，因此 value 数组不能改变。

​	所以，String 是不可变的。

**那为什么String要设计成不可变的？**

主要有以下几点原因：

1. **线程安全**。同一个字符串实例可以被多个线程共享，因为字符串不可变，本身就是线程安全的。
2. **支持 hash 映射和缓存**。因为 String 的 hash 值经常会使用到，比如作为 Map 的键，不可变的特性使得 hash 值也不会变，不需要重新计算，能提高我们程序的性能。
3. **出于安全考虑**。网络地址 URL、文件路径 path、密码通常情况下都是以 String 类型保存，假若String 不是固定不变的，将会引起各种安全隐患。比如将密码用 String 的类型保存，那么它将一直留在内存中，直到垃圾收集器把它清除。假如 String 类不是固定不变的，那么这个密码可能会被改变，导致出现安全隐患。
4. **字符串常量池优化**。String 对象创建之后，会缓存到字符串常量池中，下次需要创建同样的对象时，可以直接返回缓存的引用。

**既然我们的 String 是不可变的，它内部还有很多 substring， replace， replaceAll 这些操作的方法。这些方法好像会改变 String 对象？怎么解释呢 ？**

​	其实不是的，我们每次调用 replace 等方法，其实会在堆内存中创建了一个新的对象。然后其 value 数组引用指向不同的对象。

## String, StringBuffer 和 StringBuilder 区别

​	String 是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个 final 类型的 字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对 String 的操作都会生成新的 String 对象。因此 String 是线程安全的。

```java
private final char value[];
```

​	每次 + 操作 ： 隐式在堆上 new 了一个跟原字符串相同的 StringBuilder 对象，再调用 append 方法 拼 接 + 后面的字符。

​	StringBuffer 和 StringBuilder他们两都继承了 AbstractStringBuilder 抽象类，从 AbstractStringBuilder 抽象类中我们可以看到

```java
/**
* The value is used for character storage.
*/
char[] value;
```

​	他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用 StringBuffer 和  StringBuilder 来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所 以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

##什么是 StringJoiner？

​	StringJoiner 是 Java 8 新增的一个 API，它基于 StringBuilder 实现，用于实现对字符串之间通过分隔符拼接的场景。

​	StringJoiner 有两个构造方法，第一个构造要求依次传入分隔符、前缀和后缀。第二个构造则只要求传入分隔符即可（前缀和后缀默认为空字符串）。

```java
StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix)
StringJoiner(CharSequence delimiter)
```

​	这个 API 主要是为了解决有些字符串拼接场景，使用 StringBuffer 或 StringBuilder 显得比较繁琐的问题。

## String 类的常用方法有哪些？

- indexOf()：返回指定字符的索引。

- charAt()：返回指定索引处的字符。

- replace()：字符串替换。

- trim()：去除字符串两端空白。

- split()：分割字符串，返回一个分割后的字符串数组。

- getBytes()：返回字符串的 byte 类型数组。

- length()：返回字符串长度。

- toLowerCase()：将字符串转成小写字母。

- toUpperCase()：将字符串转成大写字符。

- substring()：截取字符串。

- equals()：字符串比较。


## new String("dabin") 会创建几个对象？

使用这种方式会创建两个字符串对象（前提是字符串常量池中没有 "dabin" 这个字符串对象）。

- "dabin" 属于字符串字面量，因此编译时期会在字符串常量池中创建一个字符串对象，指向这个 "dabin" 字符串字面量；
- 使用 new 的方式会在堆中创建一个字符串对象。

## 什么是字符串常量池？

​	字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确 定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。

 	当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添 加一个新的字符串，并返回这个新字符串的引用。 

​	下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 "aaa" 放到 String Pool 中，然后返回这个字 符串引用，因此 s3 和 s4 引用的是同一个字符串。

​	在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到 堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。

## String最大长度是多少？

​	String类提供了一个length方法，返回值为int类型，而int的取值上限为2^31 -1。所以理论上String的最大长度为2^31 -1。

**达到这个长度的话需要多大的内存吗**？

​	String内部是使用一个 char 数组来维护字符序列的，一个 char 占用两个字节。如果说 String 最大长度是 2^31 -1 的话，那么最大的字符串占用内存空间约等于 4GB。也就是说，我们需要有大于 4GB 的 JVM 运行内存才行。

**那String一般都存储在JVM的哪块区域呢**？

​	字符串在 JVM 中的存储分两种情况，一种是 String 对象，存储在 JVM 的堆栈中。一种是字符串常量，存储在常量池里面。

**什么情况下字符串会存储在常量池呢**？

​	当通过字面量进行字符串声明时，比如 String s = "程序员";，这个字符串在编译之后会以常量的形式进入到常量池。

**那常量池中的字符串最大长度是2^31-1吗**？

​	不是的，常量池对 String 的长度是有另外限制的。Java中的 UTF-8 编码的 Unicode 字符串在常量池中以 CONSTANT_Utf8 类型表示。

```java
CONSTANT_Utf8_info {
    u1 tag;
    u2 length;
    u1 bytes[length];
}
```

​	length 在这里就是代表字符串的长度，length 的类型是 u2，u2 是无符号的16位整数，也就是说最大长度可以做到 2^16-1 即 65535。

​	不过 javac 编译器做了限制，需要 length < 65535。所以字符串常量在常量池中的最大长度是 65535 - 1 = 65534。

**最后总结一下：**

String 在不同的状态下，具有不同的长度限制。

- 字符串常量长度不能超过 65534
- 堆内字符串的长度不超过 2^31-1

## Object 常用方法有哪些？

- clone 方法
  - 保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常，深拷贝也需要实现 Cloneable，同时其成员变量为引用类型 的也需要实现 Cloneable，然后重写 clone 方法。 

- finalize 方法
  -  该方法和垃圾收集器有关系，判断一个对象是否可以被回收的最后一步就是判断是否重写了此方 法。

-  equals 方法 
  - 该方法使用频率非常高。一般 equals 和 == 是不一样的，但是在 Object 中两者是一样的。子类一 般都要重写这个方法。 
- hashCode 方法 
  - 该方法用于哈希查找，重写了 equals 方法一般都要重写 hashCode 方法，这个方法在一些具有哈 希功能的 Collection 中用到。 一般必须满足 obj1.equals(obj2)==true 。可以推出 obj1.hashCode()==obj2.hashCode() ，但是 hashCode 相等不一定就满足 equals。不过为了提高效率，应该尽量使上面两个条件接近等价。 JDK 1.6、1.7 默认是返回随机数； JDK 1.8 默认是通过和当前线程有关的一个随机数 + 三个确定值，运用 Marsaglia’s xorshift scheme 随机数算法得到的一个随机数。 
- wait 方法
  -  配合 synchronized 使用，wait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥 有者，也就是具有该对象的锁。wait() 方法一直等待，直到获得锁或者被中断。wait(long timeout) 设定一个超时间隔，如果在规定时间内没有获得锁就返回。 调用该方法后当前线程进入睡眠状态，直到以下事件发生。 1. 其他线程调用了该对象的 notify 方法； 2. 其他线程调用了该对象的 notifyAll 方法； 3. 其他线程调用了 interrupt 中断该线程； 4. 时间间隔到了。 此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。 
- notify 方法 
  - 配合 synchronized 使用，该方法唤醒在该对象上等待队列中的某个线程（同步队列中的线程是给 抢占 CPU 的线程，等待队列中的线程指的是等待唤醒的线程）。
- notifyAll 方法 
  - 配合 synchronized 使用，该方法唤醒在该对象上等待队列中的所有线程。 

**总结：**

​	只要把上面几个方法熟悉就可以了，toString 和 getClass 方法可以不用去讨论它们。该题目考察的 是对 Object 的熟悉程度，平时用的很多方法并没看其定义但是也在用，比如说：wait() 方法， equals() 方法等。 大致意思：Object 是所有类的根，是所有类的父类，所有对象包括数组都实现了 Object 的方法。

## 讲讲深拷贝和浅拷贝？

**浅拷贝**：拷⻉对象和原始对象的引⽤类型引用同⼀个对象。

​	以下例子，Cat 对象里面有个 Person 对象，调用 clone 之后，克隆对象和原对象的 Person 引用的是同一个对象，这就是浅拷贝。

```java
public class Cat implements Cloneable {
    private String name;
    private Person owner;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    public static void main(String[] args) throws CloneNotSupportedException {
        Cat c = new Cat();
        Person p = new Person(18, "程序员大彬");
        c.owner = p;

        Cat cloneCat = (Cat) c.clone();
        p.setName("大彬");
        System.out.println(cloneCat.owner.getName());
    }
    //output
    //大彬
}
```

**深拷贝**：拷贝对象和原始对象的引用类型引用不同的对象。(创建一个新的并指向它)

​	以下例子，在 clone 函数中不仅调用了 super.clone，而且调用 Person 对象的 clone 方法（Person 也要实现 Cloneable 接口并重写clone 方法），从而实现了深拷贝。可以看到，拷贝对象的值不会受到原对象的影响。

```java
public class Cat implements Cloneable {
    private String name;
    private Person owner;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Cat c = null;
        c = (Cat) super.clone();
        c.owner = (Person) owner.clone();//拷贝Person对象
        return c;
    }

    public static void main(String[] args) throws CloneNotSupportedException {
        Cat c = new Cat();
        Person p = new Person(18, "程序员大彬");
        c.owner = p;

        Cat cloneCat = (Cat) c.clone();
        p.setName("大彬");
        System.out.println(cloneCat.owner.getName());
    }
    //output
    //程序员大彬
}
```

## Hashcode的作用

​	Hashcode 的作用 java 的集合有两类，一类是 List，还有一类是Set。前者有序可重复，后者无序不重复。当我们在 set 中插入的时候怎么判断是否已经存在该元素呢，可以通过 equals 方法。但是如果元素太多，用这样 的方法就会比较满。 

​	于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每 个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的 哈希码就可以确定该对象应该存储的那个区域。 

​	hashCode 方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当 集合要添加新的元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如 果这个位置上已经有元素了，就调用它的 equals 方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用 equals 方法的次数就大大降低了，几乎只需要一两次。

## 两个对象的 hashCode() 相同，则 equals()是否也一定为 true？

​	在产生 hash 冲突时,两个不相等的对象就会有相同的 hashcode 值.

equals 与 hashcode 的关系：

1. 如果两个对象调用 equals 比较返回 true，那么它们的 hashCode 值一定要相同；
2. 如果两个对象的 hashCode 相同，它们并不一定相同。

​	hashcode 方法主要是用来**提升对象比较的效率**，先进行 hashcode() 的比较，如果不相同，那就不必在进行 equals 的比较，这样就大大减少了 equals 比较的次数，当比较对象的数量很大的时候能提升效率

## 为什么重写 equals 时一定要重写 hashCode？

​	之所以重写`equals()`要重写`hashcode()`，是为了保证`equals()`方法返回 true 的情况下 hashcode 值也要一致，如果重写了`equals()`没有重写`hashcode()`，就会出现两个对象相等但`hashcode()`不相等的情况。

​	它会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法对比的是两个不同引用地址的对象，所以结果是 false。

​	这样，当用其中的一个对象作为键保存到 hashMap、hashTable 或 hashSet 中，再以另一个对象作为键值去查找他们的时候，则会查找不到。

## Java创建对象有几种方式？

Java创建对象有以下几种方式：

- 用new语句创建对象。
- 使用反射，使用Class.newInstance()创建对象。
- 调用对象的clone()方法。
- 运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。

## 说说类实例化的顺序

Java中类实例化顺序：

- 1． 父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
- 2． 子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
- 3． 父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
- 4． 父类构造方法
- 5． 子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
- 6． 子类构造方法

 **总结：父类静态成员和静态代码块->子类静态成员和静态代码块->父类非静态\**成员和\*\*非静态\*\**\*代码块->父类构造方法->子类\**非静态\*\*成员和\*\**\*非静态代码块->子类构造方法**

## equals 和 == 有什么区别？

​	**==** : 它的作用是判断两个对象的内存地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 比较的是值，引用数据类型比较的是内存地址)

​	**equals()** : 它的作用也是判断两个对象是否相等。有两种使用情况：

​		情况1：类没有覆盖 equals() 方法，等价于通过“==”比较这两个对象。

​		情况2：类覆盖了 equals() 方法。一般我们都覆盖 equals() 方法来判断两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

​	String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。

## static 关键字都有哪些用法?

​	static 可以用来修饰类的成员方法、类的成员变量。被 static 所修饰的 变量/ 方法 都属于类的静态资源,类实例所共享.

​	static变量也称作**静态变量**，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。

​	 除了 静态变量和静态方法 之外，static 也用于静态块,多用于初始化操作:

```java
public calss PreCache{
 static{
 //执行相关操作
 }
}
```

​	此外 static 也多用于修饰内部类,此时称之为静态内部类.**在静态方法里**，使用⾮静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。⽽静态内部类不需要。

​	最后一种用法就是静态导包,即 import static .

​	import static 是在 JDK 1.5 之后引入的新特性,可以用 来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:

```java
import static java.lang.Math.*;
public class Test{
 public static void main(String[] args){
 //System.out.println(Math.sin(20));传统做法
 System.out.println(sin(20));
 }
}
```

##final有哪些用法?

final 也是很多面试喜欢问的地方,但我觉得这个问题很无聊,通常能回答下以下5点就不错了: 

- 被 final 修饰的类不可以被继承 
- 被 final 修饰的方法不可以被重写 
- 被 final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。
- 如果修饰引用,那么表示引用不可变,引用指向的内容可变. 
- 被 final 修饰的方法，JVM 会尝试将其内联,以提高运行效率 
- 被 final 修饰的常量,在编译阶段会存入常量池中.

除此之外,编译器对 final 域要遵守的两个重排序规则更好:

​	在构造函数内对一个 final 域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作 之间不能重排序 初次读一个包含final 域的对象的引用,与随后初次读这个 final 域,这两个操作之间不 能重排序.

## final, finally, finalize 的区别

​	final 用于修饰属性、方法和类, 分别表示属性不能被重新赋值，方法不可被覆盖，类不可被继承。

​	finally 是异常处理语句结构的一部分，一般以`try-catch-finally`出现，`finally`代码块表示总是被执行。

​	finalize 是Object类的一个方法，该方法一般由垃圾回收器来调用，当我们调用`System.gc()`方法的时候，由垃圾回收器调用	`finalize()`方法，回收垃圾，JVM并不保证此方法总被调用

## 方法重载和重写的区别？

**同个类中的多个方法可以有相同的方法名称，但是有不同的参数列表，这就称为方法重载**。

​	1.重载 Overload 是一个类中多态性的一种表现

​	2.重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序) 

​	3.重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准

**方法的重写描述的是父类和子类之间的。当父类的功能无法满足子类的需求，可以在子类对方法进行重写**。

​	1.发生在父类与子类之间 

​	2.方法名，参数列表必须相同 

​	3.返回类型小于等于父类

​	4.访问修饰符大于等于父类（里氏代换原则） （public>protected>default>private) 

​	5.抛出的异常小于等于父类

​	6.如果父类方法访问修饰符为 private 则子类中就不是重写。

## 接口与抽象类对比？

从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

**相同点**

- 接口和抽象类都不能实例化
- 都位于继承的顶端，用于被其他类实现或继承
- 都包含抽象方法，其子类都必须重写这些抽象方法

**不同点**

- 抽象类可以有方法实现，而接口的方法中只能是抽象方法（Java 8 之后接口方法可以有默认实现）；
- 抽象类可以由构造器，接口不能有构造器
- 抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是 `public static final` 类型；
- 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法（Java 8之后接口可以有静态方法）；
- 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

##成员变量与局部变量的区别有哪些

- 成员变量作用范围是整个类，局部变量在方法或者语句块内有效。
- 成员变量随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。局部变量在方法被调用的时候存在，方法调用完会自动释放，存储在栈内存中
- 成员变量有默认初始值。局部变量没有默认初始值，使用前必须赋值

## 泛型常用特点

​	"泛型" 意味着编写的代码可以被不同类型的对象所重用。

​	比如我们用的非常多的ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如 Integer, String，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约 束集合中只存放Integer类型的元素，如

```java
List iniData = new ArrayList<>()
```

使用泛型的好处？

​	以集合来举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整 型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型 数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向 上转型为Object。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。

##3*0.1 == 0.3返回值是什么

​	false，因为有些浮点数不能完全精确的表示出来.

## a=a+b与a+=b有什么区别吗?

​	+= 操作符会进行隐式自动类型转换,此处 a+=b 隐式的将加操作的结果类型强制转换为持有结果的类 型,而 a=a+b 则不会自动进行类型转换.

如：

```java
byte a = 127;
byte b = 127;
b = a + b; // 报编译错误:cannot convert from int to byte
b += a;
```

以下代码是否有错,有的话怎么改？

​	有错误.short类型在进行运算时会自动提升为int类型,也就是说 s1+1 的运算结果是int类型,而s1是 short类型,此时编译器会报错. 

正确写法：

```java
short s1= 1;
s1 += 1;
```

​	+= 操作符会对右边的表达式结果强转匹配左边的数据类型,所以没错.

##什么是异常？请描述一下Java异常架构

​	Java异常是Java提供的一种识别及响应错误的一致性机制。

​	Java异常处理机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。

​	Throwable 是 Java 语言中所有错误与异常的超类。

​	Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。

​	Throwable 包含了线程创建时执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。

## Error和Exception的区别？

​	**Error**：JVM 无法解决的严重问题，如栈溢出`StackOverflowError`、内存溢出`OOM`等。程序无法处理的错误。

​	**Exception**：其它因编程错误或偶然的外在因素导致的一般性问题。可以在代码中进行处理。如：空指针异常、数组下标越界等。

## 常见的Exception有哪些？

常见的RuntimeException：

1. `ClassCastException` //类型转换异常
2. `IndexOutOfBoundsException` //数组越界异常
3. `NullPointerException` //空指针
4. `ArrayStoreException` //数组存储异常
5. `NumberFormatException` //数字格式化异常
6. `ArithmeticException` //数学运算异常

checked Exception：

1. `NoSuchFieldException` //反射异常，没有对应的字段
2. `ClassNotFoundException` //类没有找到异常
3. `IllegalAccessException` //安全权限异常，可能是反射时调用了private方法

## 什么是运行时异常，编译时异常？什么是受检异常与非受检异常

​	程序本身可以捕获并且可以处理的异常。

​	Exception 这种异常又分为两类：运行时异常和编译时异常。

#### 运行时异常

​	**定义**：RuntimeException 类及其子类。

​	**特点**：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既"没有通过 throws 声明抛出它"，也"没有用 try-catch 语句捕获它"，还是会编译通过。比如 NullPointerException 空指针异常、ArrayIndexOutBoundException 数组下标越界异常、ClassCastException 类型转换异常、ArithmeticExecption 算术异常。此类异常属于非受检异常，在程序中可以选择捕获，抛出，也可以不处理，此类异常一般是由程序逻辑错误引起的，需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！

#### 编译时异常

​	**定义**: Exception 中除 RuntimeException 及其子类之外的异常。

​	**特点**: Java 编译器会检查它。如果程序中出现此类异常，比如 ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过 throws 进行声明抛出，要么通过 try-catch 进行捕获处理，否则不能通过编译。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。

Java 的所有异常可以分为受检异常（checked exception）和非受检异常（unchecked exception）。

#### 受检异常

​	编译器要求必须处理的异常。**Exception 中除 RuntimeException 及其子类之外的异常都属于受检异常**。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用 try-catch 捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过。

#### 非受检异常

​	编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有 try-catch 捕获它，也没有使用 throws 抛出该异常，编译也会正常通过。**该类异常包括运行时异常（RuntimeException及其子类）和错误（Error）。**

## 运行时异常和非运行时异常（checked）的区别？

​	运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。Java 编译器不会检查运行时异常。

​	受检异常是 Exception 中 除 RuntimeException 及其子类之外的异常。Java 编译器会检查受检异常。

​	**RuntimeException 异常和受检异常之间的区别**：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用 RuntimeException 异常。

## throw 和throws 的区别？

- Java 中的异常处理除了包括捕获和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常。

  **throws 关键字和 throw 关键字在使用上的几点区别如下**：

  - throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常。
  - throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。调用该方法的方法必须包含可处理异常的代码，否则也要在方法声明中用 throws 关键字声明相应的异常。

## try-catch-finally 中哪个部分可以省略？

​	try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。

## try catch finally，try里有return，finally还执行么？

​	执行，并且 finally 的执行早于 try 里面的 return

结论：

​	1、不管有木有出现异常，finally 块中代码都会执行； 

​	2、当 try 和 catch 中有 return 时，finally 仍然会执行； 

​	3、finally 是在 return 后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管 finally 中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在 finally 执行前确定的； 

​	4、finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值。

##从性能角度来审视一下 Java 的异常处理机制

- try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；
- 利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效；
- Java 每实例化一个 Exception，都会对当时的堆栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。

##说几个Java异常处理最佳实践

- **在 finally 块中清理资源或者使用 try-with-resource 语句**
- 对异常进行文档说明
- 使用描述性消息抛出异常
- Throw early, catch late 原则，在发现问题的时候，第一时间抛出，能够更加清晰地反映问题
- **尽量不要捕获类似 Exception 这样的通用异常，优先捕获最具体的异常**
- 不要捕获 Throwable 类
- **不要忽略异常，也不要生吞（swallow）异常**
- 不要记录并抛出异常，但这经常会给同一个异常输出多条日志。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。
- 
- 包装异常时不要抛弃原始的异常
- **不要使用异常控制程序的流程**
- 尽量使用标准异常
- 异常会影响性能

## BIO/NIO/AIO区别的区别？

​	**同步阻塞IO** : 用户进程发起一个IO操作以后，必须等待IO操作的真正完成后，才能继续运行。

​	**同步非阻塞IO**: 客户端与服务器通过Channel连接，采用多路复用器轮询注册的`Channel`。提高吞吐量和可靠性。用户进程发起一个IO操作以后，可做其它事情，但用户进程需要轮询IO操作是否完成，这样造成不必要的CPU资源浪费。

​	**异步非阻塞IO**: 非阻塞异步通信模式，NIO的升级版，采用异步通道实现异步通信，其read和write方法均是异步方法。用户进程发起一个IO操作，然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。类似Future模式。

## 守护线程是什么？

- 守护线程是运行在后台的一种特殊进程。
- 它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。
- 在 Java 中垃圾回收线程就是特殊的守护线程。

## Java支持多继承吗？

​	java中，**类不支持**多继承。**接口才支持**多继承。接口的作用是拓展对象功能。当一个子接口继承了多个父接口时，说明子接口拓展了多个功能。当一个类实现该接口时，就拓展了多个的功能。

Java不支持多继承的原因：

- 出于安全性的考虑，如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体要继承哪个。
- Java 提供了接口和内部类以达到实现多继承功能，弥补单继承的缺陷。

## 如何实现对象克隆？

- 实现`Cloneable`接口，重写 `clone()` 方法。这种方式是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。如果对象的属性的 Class 也实现 `Cloneable` 接口，那么在克隆对象时也会克隆属性，即深拷贝。
- 结合序列化，深拷贝。
- 通过`org.apache.commons`中的工具类`BeanUtils`和`PropertyUtils`进行对象复制。

## 同步和异步的区别？

​	同步：发出一个调用时，在没有得到结果之前，该调用就不返回。

​	异步：在调用发出后，被调用者返回结果之后会通知调用者，或通过回调函数处理这个调用。

## 阻塞和非阻塞的区别？

​	阻塞和非阻塞关注的是线程的状态。

​	阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会恢复运行。

​	非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

> 举个例子，理解下同步、阻塞、异步、非阻塞的区别：
>
> 同步就是烧开水，要自己来看开没开；异步就是水开了，然后水壶响了通知你水开了（回调通知）。阻塞是烧开水的过程中，你不能干其他事情，必须在旁边等着；非阻塞是烧开水的过程里可以干其他事情。

## Java8 的新特性有哪些？

​	Lambda 表达式：Lambda允许把函数作为一个方法的参数

​	Stream API ：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中

​	默认方法：默认方法就是一个在接口里面有了一个实现的方法。

​	Optional 类 ：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。

​	Date Time API ：加强对日期与时间的处理。

## 序列化和反序列化

- 序列化：把对象转换为字节序列的过程称为对象的序列化.
- 反序列化：把字节序列恢复为对象的过程称为对象的反序列化.

## 什么时候需要用到序列化和反序列化呢?

​	当我们只在本地 JVM 里运行下 Java 实例，这个时候是不需要什么序列化和反序列化的，但当我们需要将内存中的对象持久化到磁盘，数据库中时，当我们需要与浏览器进行交互时，当我们需要实现 RPC 时，这个时候就需要序列化和反序列化了.

​	前两个需要用到序列化和反序列化的场景，是不是让我们有一个很大的疑问? 我们在与浏览器交互时，还有将内存中的对象持久化到数据库中时，好像都没有去进行序列化和反序列化，因为我们都没有实现 Serializable 接口，但一直正常运行.

下面先给出结论:

​	**只要我们对内存中的对象进行持久化或网络传输，这个时候都需要序列化和反序列化.**

​	实际上我们并不是将整个对象持久化到数据库中，而是将对象中的属性持久化到数据库中，而这些属性（如Date/String）都实现了 Serializable 接口。

## 实现序列化和反序列化为什么要实现 Serializable 接口?

​	在 Java 中实现了 Serializable 接口后， JVM 在类加载的时候就会发现我们实现了这个接口，然后在初始化实例对象的时候就会在底层帮我们实现序列化和反序列化。

​	如果被写对象类型不是String、数组、Enum，并且没有实现Serializable接口，那么在进行序列化的时候，将抛出NotSerializableException。

## 实现 Serializable 接口之后，为什么还要显示指定 serialVersionUID 的值?

​	如果不显示指定 serialVersionUID，JVM 在序列化时会根据属性自动生成一个 serialVersionUID，然后与属性一起序列化，再进行持久化或网络传输. 在反序列化时，JVM 会再根据属性自动生成一个新版 serialVersionUID，然后将这个新版 serialVersionUID 与序列化时生成的旧版 serialVersionUID 进行比较，如果相同则反序列化成功，否则报错.

​	如果显示指定了 serialVersionUID，JVM 在序列化和反序列化时仍然都会生成一个 serialVersionUID，但值为我们显示指定的值，这样在反序列化时新旧版本的 serialVersionUID 就一致了.

​	如果我们的类写完后不再修改，那么不指定serialVersionUID，不会有问题，但这在实际开发中是不可能的，我们的类会不断迭代，一旦类被修改了，那旧对象反序列化就会报错。 所以在实际开发中，我们都会显示指定一个 serialVersionUID。

## static 属性为什么不会被序列化?

​	因为序列化是针对对象而言的，而 static 属性优先于对象存在，随着类的加载而加载，所以不会被序列化.

​	看到这个结论，是不是有人会问，serialVersionUID 也被 static 修饰，为什么 serialVersionUID 会被序列化? 其实 serialVersionUID 属性并没有被序列化，JVM 在序列化对象时会自动生成一个 serialVersionUID，然后将我们显示指定的 serialVersionUID 属性值赋给自动生成的 serialVersionUID.

## transient关键字的作用？

​	Java语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。

​	也就是说被transient修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后， transient 变量的值被设为初始值， 如 int 型的是 0，对象型的是 null。

## 什么是反射？

​	动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。

​	在运行状态中，对于任意一个类，能够知道这个类的所有属性和方法。对于任意一个对象，能够调用它的任意一个方法和属性。

## 反射有哪些应用场景呢？

1. JDBC连接数据库时使用`Class.forName()`通过反射加载数据库的驱动程序
2. Eclispe、IDEA等开发工具利用反射动态解析对象的类型与结构，动态提示对象的属性和方法
3. Web服务器中利用反射调用了Sevlet的`service`方法
4. JDK动态代理底层依赖反射实现

## 讲讲什么是泛型？

​	Java泛型是JDK 5中引⼊的⼀个新特性， 允许在定义类和接口的时候使⽤类型参数。声明的类型参数在使⽤时⽤具体的类型来替换。

​	泛型最⼤的好处是可以提⾼代码的复⽤性。以List接口为例，我们可以将String、 Integer等类型放⼊List中， 如不⽤泛型， 存放String类型要写⼀个List接口， 存放Integer要写另外⼀个List接口， 泛型可以很好的解决这个问题。

## 如何停止一个正在运行的线程？

有几种方式。

​	1、**使用线程的stop方法**。

​			使用stop()方法可以强制终止线程。不过stop是一个被废弃掉的方法，不推荐使用。

​			使用Stop方法，会一直向上传播ThreadDeath异常，从而使得目标线程解锁所有锁住的监视器，即释放掉所有的对象锁。使得之前被锁住的对象得不到同步的处理，因此可能会造成数据不一致的问题。

​	2、**使用interrupt方法中断线程**，该方法只是告诉线程要终止，但最终何时终止取决于计算机。调用interrupt方法仅仅是在当前线程			中打了一个停止的标记，并不是真的停止线程。

​			接着调用 Thread.currentThread().isInterrupted()方法，可以用来判断当前线程是否被终止，通过这个判断我们可以做一些业务逻辑处理，通常如果isInterrupted返回true的话，会抛一个中断异常，然后通过try-catch捕获。

​	3、**设置标志位**

​			设置标志位，当标识位为某个值时，使线程正常退出。设置标志位是用到了共享变量的方式，为了保证共享变量在内存中的可见性，可以使用volatile修饰它，这样的话，变量取值始终会从主存中获取最新值。

​			但是这种volatile标记共享变量的方式，在线程发生阻塞时是无法完成响应的。比如调用Thread.sleep() 方法之后，线程处于不可运行状态，即便是主线程修改了共享变量的值，该线程此时根本无法检查循环标志，所以也就无法实现线程中断。

​			因此，interrupt() 加上手动抛异常的方式是目前中断一个正在运行的线程**最为正确**的方式了。

## 什么是跨域？

​	简单来讲，跨域是指从一个域名的网页去请求另一个域名的资源。由于有**同源策略**的关系，一般是不允许这么直接访问的。但是，很多场景经常会有跨域访问的需求，比如，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域问题。

**那什么是同源策略呢**？

​	所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

同源策略限制以下几种行为：

```mipsasm
1. Cookie、LocalStorage 和 IndexDB 无法读取
2. DOM 和 Js对象无法获得
3. AJAX 请求不能发送
```

**为什么要有同源策略**？

​	举个例子，假如你刚刚在网银输入账号密码，查看了自己的余额，然后再去访问其他带颜色的网站，这个网站可以访问刚刚的网银站点，并且获取账号密码，那后果可想而知。因此，从安全的角度来讲，同源策略是有利于保护网站信息的。

## 跨域问题怎么解决呢？

嗯，有以下几种方法：

​	**CORS**，跨域资源共享

​			CORS（Cross-origin resource sharing），跨域资源共享。CORS 其实是浏览器制定的一个规范，浏览器会自动进行 CORS 通信，它的实现主要在服务端，通过一些 HTTP Header 来限制可以访问的域，例如页面 A 需要访问 B 服务器上的数据，如果 B 服务器 上声明了允许 A 的域名访问，那么从 A 到 B 的跨域请求就可以完成。

​	**@CrossOrigin注解**

​			如果项目使用的是Springboot，可以在Controller类上添加一个 @CrossOrigin(origins ="*") 注解就可以实现对当前controller 的跨域访问了，当然这个标签也可以加到方法上，或者直接加到入口类上对所有接口进行跨域处理。注意SpringMVC的版本要在4.2或以上版本才支持@CrossOrigin。

​	**nginx反向代理接口跨域**

​			nginx反向代理跨域原理如下： 首先同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。

​			nginx反向代理接口跨域实现思路如下：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

​	**通过jsonp跨域**

​			通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，这是浏览器允许的操作，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。

## 设计接口要注意什么?

1. **接口参数校验**。接口必须校验参数，比如入参是否允许为空，入参长度是否符合预期。
2. 设计接口时，充分考虑接口的**可扩展性**。思考接口是否可以复用，怎样保持接口的可扩展性。
3. **串行调用考虑改并行调用**。比如设计一个商城首页接口，需要查商品信息、营销信息、用户信息等等。如果是串行一个一个查，那耗时就比较大了。这种场景是可以改为并行调用的，降低接口耗时。
4. 接口是否需要**防重**处理。涉及到数据库修改的，要考虑防重处理，可以使用数据库防重表，以唯一流水号作为唯一索引。
5. **日志打印全面**，入参出参，接口耗时，记录好日志，方便甩锅。
6. 修改旧接口时，注意**兼容性设计**。
7. **异常处理得当**。使用finally关闭流资源、使用log打印而不是e.printStackTrace()、不要吞异常等等
8. 是否需要考虑**限流**。限流为了保护系统，防止流量洪峰超过系统的承载能力。

## 过滤器和拦截器有什么区别？

​	1、**实现原理不同**。

​			过滤器和拦截器底层实现不同。过滤器是基于函数回调的，拦截器是基于Java的反射机制（动态代理）实现的。一般自定义的过滤器中都会实现一个doFilter()方法，这个方法有一个FilterChain参数，而实际上它是一个回调接口。

​	2、**使用范围不同**。

​			过滤器实现的是 javax.servlet.Filter 接口，而这个接口是在Servlet规范中定义的，也就是说过滤器Filter的使用要依赖于Tomcat等容器，导致它只能在web程序中使用。而拦截器是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。拦截器不仅能应用在web程序中，也可以用于Application、Swing等程序中。

​	3、**使用的场景不同**。

​			因为拦截器更接近业务系统，所以拦截器主要用来实现项目中的业务判断的，比如：日志记录、权限判断等业务。而过滤器通常是用来实现通用功能过滤的，比如：敏感词过滤、响应数据压缩等功能。

​	4、**触发时机不同**。

​			过滤器Filter是在请求进入容器后，但在进入servlet之前进行预处理，请求结束是在servlet处理完以后。

拦截器 Interceptor 是在请求进入servlet后，在进入Controller之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。

​	5、**拦截的请求范围不同**。

​			请求的执行顺序是：请求进入容器 -> 进入过滤器 -> 进入 Servlet -> 进入拦截器 -> 执行控制器。可以看到过滤器和拦截器的执行时机也是不同的，过滤器会先执行，然后才会执行拦截器，最后才会进入真正的要调用的方法。

## 对接第三方接口要考虑什么？

嗯，需要考虑以下几点：

1. 确认接口对接的**网络协议**，是https/http或者自定义的私有协议等。
2. 约定好**数据传参、响应格式**（如application/json），弱类型对接强类型语言时要特别注意
3. **接口安全**方面，要确定身份校验方式，使用token、证书校验等
4. 确认是否需要接口调用失败后的**重试**机制，保证数据传输的最终一致性。
5. **日志记录要全面**。接口出入参数，以及解析之后的参数值，都要用日志记录下来，方便定位问题（甩锅）。

## 后端接口性能优化有哪些方法？

有以下这些方法：

​	1、**优化索引**。给where条件的关键字段，或者`order by`后面的排序字段，加索引。

​	2、**优化sql语句**。比如避免使用select *、批量操作、避免深分页、提升group by的效率等

​	3、**避免大事务**。使用@Transactional注解这种声明式事务的方式提供事务功能，容易造成大事务，引发其他的问题。应该避免在事务中一次性处理太多数据，将一些跟事务无关的逻辑放到事务外面执行。

​	4、**异步处理**。剥离主逻辑和副逻辑，副逻辑可以异步执行，异步写库。比如用户购买的商品发货了，需要发短信通知，短信通知是副流程，可以异步执行，以免影响主流程的执行。

​	5、**降低锁粒度**。在并发场景下，多个线程同时修改数据，造成数据不一致的情况。这种情况下，一般会加锁解决。但如果锁加得不好，导致锁的粒度太粗，也会非常影响接口性能。

​	6、**加缓存**。如果表数据量非常大的话，直接从数据库查询数据，性能会非常差。可以使用Redis`和`memcached提升查询性能，从而提高接口性能。

​	7、**分库分表**。当系统发展到一定的阶段，用户并发量大，会有大量的数据库请求，需要占用大量的数据库连接，同时会带来磁盘IO的性能瓶颈问题。或者数据库表数据非常大，SQL查询即使走了索引，也很耗时。这时，可以通过分库分表解决。分库用于解决数据库连接资源不足问题，和磁盘IO的性能瓶颈问题。分表用于解决单表数据量太大，sql语句查询数据时，即使走了索引也非常耗时问题。

​	8、**避免在循环中查询数据库**。循环查询数据库，非常耗时，最好能在一次查询中获取所有需要的数据。

## 为什么在阿里巴巴 Java 开发手册中强制要求使用包装类型定义属性呢？

​	嗯，以布尔字段为例，当我们没有设置对象的字段的值的时候，Boolean类型的变量会设置默认值为`null`，而boolean类型的变量会设置默认值为`false`。

​	也就是说，包装类型的默认值都是null，而基本数据类型的默认值是一个固定值，如boolean是false，byte、short、int、long是0，float是0.0f等。

​	举一个例子，比如有一个扣费系统，扣费时需要从外部的定价系统中读取一个费率的值，我们预期该接口的返回值中会包含一个浮点型的费率字段。当我们取到这个值得时候就使用公式：金额*费率=费用 进行计算，计算结果进行划扣。

​	如果由于计费系统异常，他可能会返回个默认值，如果这个字段是Double类型的话，该默认值为null，如果该字段是double类型的话，该默认值为0.0。

​	如果扣费系统对于该费率返回值没做特殊处理的话，拿到null值进行计算会直接报错，阻断程序。拿到0.0可能就直接进行计算，得出接口为0后进行扣费了。这种异常情况就无法被感知。

​	**那我可以对0.0做特殊判断，如果是0就阻断报错，这样是否可以呢？**

​	不对，这时候就会产生一个问题，如果允许费率是0的场景又怎么处理呢？

​	使用基本数据类型只会让方案越来越复杂，坑越来越多。

​	这种使用包装类型定义变量的方式，通过异常来阻断程序，进而可以被识别到这种线上问题。如果使用基本数据类型的话，系统可能不会报错，进而认为无异常。

​	因此，建议在POJO和RPC的返回值中使用包装类型。

## 8 招让接口性能提升 100 倍

​	**池化思想**

​			如果你每次需要用到线程，都去创建，就会有增加一定的耗时，而线程池可以重复利用线程，避免不必要的耗时。

​			比如`TCP`三次握手，它为了减少性能损耗，引入了`Keep-Alive长连接`，避免频繁的创建和销毁连接。

​	**拒绝阻塞等待**

​			如果你调用一个系统`B`的接口，但是它处理业务逻辑，耗时需要`10s`甚至更多。然后你是一直**阻塞等待，直到系统B的下游接口返回**，再继续你的下一步操作吗？这样**显然不合理**。

​			参考**IO多路复用模型**。即我们不用阻塞等待系统`B`的接口，而是先去做别的操作。等系统`B`的接口处理完，通过**事件回调**通知，我们接口收到通知再进行对应的业务操作即可。

​	**远程调用由串行改为并行**

​			比如设计一个商城首页接口，需要查商品信息、营销信息、用户信息等等。如果是串行一个一个查，那耗时就比较大了。这种场景是可以改为并行调用的，降低接口耗时。

​	**锁粒度避免过粗**

​			在高并发场景，为了防止**超卖等情况**，我们经常需要**加锁来保护共享资源**。但是，如果加锁的粒度过粗，是很影响接口性能的。

​			不管你是`synchronized`加锁还是`redis`分布式锁，只需要在共享临界资源加锁即可，不涉及共享资源的，就不必要加锁。

​	**耗时操作，考虑放到异步执行**

​			耗时操作，考虑用**异步处理**，这样可以降低接口耗时。比如用户注册成功后，短信邮件通知，是可以异步处理的。

​	**使用缓存**

​			把要查的数据，提前放好到缓存里面，需要时，**直接查缓存，而避免去查数据库或者计算的过程**。

​	**提前初始化到缓存**

​			预取思想很容易理解，就是**提前把要计算查询的数据，初始化到缓存**。如果你在未来某个时间需要用到某个经过复杂计算的数据，**才实时去计算的话，可能耗时比较大**。这时候，我们可以采取预取思想，**提前把将来可能需要的数据计算好，放到缓存中**，等需要的时候，去缓存取就行。这将大幅度提高接口性能。

​	**压缩传输内容**

​			压缩传输内容，传输报文变得更小，因此传输会更快。

